<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <title>Gemini TTS — Text to Speech</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">

    <link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABIBJREFUeJztm19oW2UYxp/3y0msy0nTTcQqdnox9EahFxsOBBGvZ0HnRaGgNc0yWVexyWbFq8BEWP+cCnVjljQLm+BFq4KKelf0QoTp5oVTxtTZBt3YaLP8q0p6zuvFqoTkzJ2mX8536vKD3DznfO/7fA8n33fOISFIJh4p9EDQG2B0AfgClm/IOLklK7uPLEhmscS+8i62rK8AaFUNvlss6DtnZ8mU2UsWQmYxtsxeVE0eABjo7gqVH5HZRyZSAwDRPXYyE+6V2kcicgPYhLQCUG1ANa0AVBtQTSsAlc2H+pbah/qW2mXUSiZZO9xf6lzvOCUBjMSWw/Fo8QN/WyDnbwvk4gPFuY0EEY8WBwvZUs708eX4QPFiPJrf7XSskgAqpn8MjGfW+gsAe/1tgdFGaiUGik+AMQVAX5N2gMWHBw5c1f9r3D+o+grssdF6GqpEtAf1zzSdbX/eucvJcFUBbHWo3RJm7rjJoW1Oxt/2u4B261NuEIuxX18tDzHx44L5krDE+FhGv9JMc27g+ArQzdIciCcIeJaJEqaPvx18vnBXM825gaMAhvtLj6J+kbovEBD90h25jLMrQFg7bHWLH5JpRgWOAiCQ7XlEcl+pqcDxIqiKV/pzHZqmdZMws2PTHT/Lru/pbTAeKfQIn7ZgMeZN0/fTcKT4DsBSrzrPBvBq5FoIRKcA/PuMQIRYIlruldnHswFUxB3dAMK1umXxkzL7eDYAsAjaySRgqzeKdwNwCS2ZZFFYLL8MsvoYwiS2Zox0KAUQqzYnF6ZEtLTPYooQLB9BvBvqCk5p+WzpdSIcAQgEBogeG46UfJNpnFBtWSbxaOklZhwnMAACg3cWF4tBAWB/7clEiLlvsclw/TyZaL8g4P7aAwRsd8eVe9jNE8D2234RbAWg2oBqBMALtSKDL6kw00yYUDdPAL8IEGXqZDttk0MWMvUiMiKb148A/BoIZ8F8hoFBI6Ufd99ic5lI62+DcBDgb0A4S+CRbF5/U1v77c7Rtc//GGIjhWMAjlWrrUVQtYGbIdgq2R5g2OuN9pFZTCZUWTkH1E+WQV/K7OPZAMZPd5aJ8CKqQyA+NTkTfE9mH88GAAATqdAcw3oAjKcg+GEj1f6C7Md0z78VnpwJLwOYb1Z9R1cAgy1bnbHpX5o4CkAwXbDViX6Qa8d9HAUwcVL/kcGf1chXyM9SFyQVOFwDiFHgvRwqHgTRboAX/KQZoye2XG2uvebjeBGcnKU/AIw10YsSPL0NuoGqAJbrFMJSY6UoZ6cK4ayemgCIahdUgPFpQ7WYPwfqtuNr+Kt8xslwJQFYq5VDYPqkSvrI76scbqSWkQ7Ng+kQgJUbCv1KwHPjpzvLTsYruRN8K7P1OoCnR2LLYQA4Or0tv5F6Rlo3YjGe6lhduXs0Hfx9PWOV3gpvdOLVTE9TBcC6Jg+0doFWAK0AVBtQTSsA1QZUIzcA5su2uonfpPaRiOS/zvL7AGr/JP19+MHgeal9JCI1ACMV/poIvQDOA7hOoI8FmT3JJNm+UvMCfwMXSVUXGkrYgQAAAABJRU5ErkJggg==" type="image/x-icon">
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        .card {
            border: none;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            border-radius: 1rem;
        }

        .form-control,
        .form-select {
            border-radius: 0.5rem;
        }

        .btn-generate {
            border-radius: 0.5rem;
            padding: 0.75rem 2rem;
            font-weight: 600;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border: none;
            color: white;
            transition: all 0.3s ease;
        }

        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        .header-icon {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        audio {
            width: 100%;
            margin: 1rem 0;
        }

        #download a {
            text-decoration: none;
            color: #fff;
        }

        .result-card {
            background: #ffffff;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        .keyword-tag {
            display: inline-block;
            padding: 2px 8px;
            background: #e9ecef;
            border-radius: 12px;
            font-size: 0.875rem;
        }


    </style>
</head>

<body>
    <div class="container py-3">
        <div class="row justify-content-center">
            <div class="col-lg-8">
                <div class="text-center mb-3">
                    <i class="bi bi-soundwave header-icon mb-3"></i>
                    <h1 class="display-5 fw-bold mb-1">Gemini Text-to-Speech</h1>
                    <p class="text-muted">Chuyển đổi văn bản thành giọng nói tự nhiên với công nghệ Gemini AI</p>
                </div> 
                <div class="card p-4 mb-4">
                    <div class="row">
                        <div class="col">
                            <div class="mb-4">
                                <label class="form-label fw-semibold">Model</label>
                                <select id="model" class="form-select">
                                    <option value="gemini-2.5-flash-preview-tts">gemini-2.5-flash-preview-tts</option>
                                    <option value="gemini-2.5-pro-preview-tts">gemini-2.5-pro-preview-tts</option>
                                </select>
                            </div>
                        </div>
                        <div class="col">
                            <div class="mb-4">
                                <label class="form-label fw-semibold">Giọng đọc</label>
                                <select id="voice" class="form-select">
                                    <option value="Zephyr">Zephyr</option>
                                    <option value="Puck">Puck</option>
                                    <option value="Charon">Charon</option>
                                    <option value="Kore">Kore</option>
                                    <option value="Fenrir">Fenrir</option>
                                    <option value="Leda">Leda</option>
                                    <option value="Orus">Orus</option>
                                    <option value="Aoede">Aoede</option>
                                    <option value="Callirrhoe">Callirrhoe</option>
                                    <option value="Autonoe">Autonoe</option>
                                    <option value="Enceladus">Enceladus</option>
                                    <option value="Lapetus">Lapetus</option>
                                    <option value="Umbriel">Umbriel</option>
                                    <option value="Algieba">Algieba</option>
                                    <option value="Despina">Despina</option>
                                    <option value="Erinome">Erinome</option>
                                    <option value="Algenib">Algenib</option>
                                    <option value="Rasalgethi">Rasalgethi</option>
                                    <option value="Laomedeia">Laomedeia</option>
                                    <option value="Achernar">Achernar</option>
                                    <option value="Alnilam">Alnilam</option>
                                    <option value="Schedar">Schedar</option>
                                    <option value="Gacrux">Gacrux</option>
                                    <option value="Pulcherrima">Pulcherrima</option>
                                    <option value="Achird">Achird</option>
                                    <option value="Zubenelgenubi" selected>Zubenelgenubi</option>
                                    <option value="Vindemiatrix">Vindemiatrix</option>
                                    <option value="Sadachbia">Sadachbia</option>
                                    <option value="Sadaltager">Sadaltager</option>
                                    <option value="Sulafat">Sulafat</option>
                                </select>
                            </div>
                        </div>  
                    </div>   
                    <div class="mb-4">
                        <label class="form-label fw-semibold">Nội dung cần đọc</label>
                        <div class="mb-3">
                            <div class="input-group">
                                <input type="text" id="url-input" class="form-control" placeholder="Nhập link tóm tắt...">
                                <button id="process-url" class="btn btn-outline-primary" type="button">
                                    <i class="bi bi-magic me-1"></i>Tóm tắt AI
                                    <span id="loading-spinner" class="spinner-border spinner-border-sm ms-1 d-none" role="status">
                                        <span class="visually-hidden">Đang xử lý...</span>
                                    </span>
                                </button>
                            </div>
                            <div id="related-content" class="mt-3" style="display: none;">
                                <div class="d-flex gap-2 mb-2">
                                    <small class="text-muted">Từ khóa chính:</small>
                                    <div id="keywords" class="d-flex gap-1 flex-wrap"></div>
                                </div>
                                <div class="row g-2">
            
                                </div>
                            </div>
                        </div>
                        <input type="text" id="style-persona" class="form-control mb-3"
                            placeholder="Phong cách / giọng điệu (tùy chọn)"
                            value="Giọng nói tự nhiên, to rõ, hơi nhanh" />
                        <textarea id="text" class="form-control" rows="14"></textarea>
                    </div> 
                    <button id="go" class="btn btn-generate w-100">
                        <i class="bi bi-play-circle me-2"></i>
                        <span id="generate-btn-text">Tạo giọng nói</span>
                        <span id="generate-spinner" class="spinner-border spinner-border-sm ms-1 d-none" role="status">
                            <span class="visually-hidden">Đang tạo...</span>
                        </span>
                    </button>
                </div> 
                <div class="result-card">
                    <label class="form-label fw-semibold mb-3">Kết quả</label>
                    <audio id="player" controls class="w-100"></audio>
                    <div id="download" class="text-center"></div>
                    <pre id="log" class="mono small text-muted mt-3"></pre>
                </div> 
                <div class="result-card mt-4">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <label class="form-label fw-semibold mb-0">Lịch sử gần đây</label>
                        <button onclick="clearHistory()" class="btn btn-outline-danger btn-sm">
                            <i class="bi bi-trash"></i> Xóa lịch sử
                        </button>
                    </div>
                    <div id="history-list" class="border rounded">
                        <!-- History items will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
        <div class="text-center p-1">
            <small class="text-muted">© 2025 Gemini Text-to-Speech by DucPro023 - Version: 1.0.0</small>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        const endpointBase = "https://generativelanguage.googleapis.com/v1beta";
        const endpointBaseModelText = "https://generativelanguage.googleapis.com/v1/models";
        
        // Danh sách API keys
        const API_KEYS = [
            "AIzaSyCMVNsdQxn-Py7ae_8GTGp6t3OXNRLSNy0",
            "AIzaSyD5RcvTe3ZImr-vxdMPhD49tWiexNXLDqc",
            "AIzaSyAYZoPjzZGh9F0H_MheGCHZYag0-QVE_Fs",
            // Thêm các key khác vào đây
        ];

        // Hàm để quản lý và luân chuyển API key
        const keyManager = {
            currentKeyIndex: 0,
            
            async getCurrentKey() {
                try {
                    // Lấy key đã lưu từ IndexedDB
                    const savedKeyIndex = await getFromIndexedDB('settings', 'currentKeyIndex');
                    if (savedKeyIndex !== undefined && savedKeyIndex < API_KEYS.length) {
                        this.currentKeyIndex = savedKeyIndex;
                    }
                    return API_KEYS[this.currentKeyIndex];
                } catch (error) {
                    console.error('Error getting current key:', error);
                    return API_KEYS[0];
                }
            },

            async switchToNextKey() {
                this.currentKeyIndex = (this.currentKeyIndex + 1) % API_KEYS.length;
                try {
                    // Lưu index key mới vào IndexedDB
                    await saveToIndexedDB('settings', 'currentKeyIndex', this.currentKeyIndex);
                } catch (error) {
                    console.error('Error saving current key index:', error);
                }
                return API_KEYS[this.currentKeyIndex];
            },

            async handleApiError(error) {
                if (error.message.includes('quota') || error.message.includes('exceeded') || 
                    error.message.includes('limit') || error.message.includes('QPS')) {
                    // Nếu là lỗi quota, chuyển sang key khác
                    if (this.currentKeyIndex < API_KEYS.length - 1) {
                        const newKey = await this.switchToNextKey();
                        return { shouldRetry: true, key: newKey };
                    } else {
                        return { shouldRetry: false, error: 'Đã hết key khả dụng. Vui lòng thử lại sau.' };
                    }
                }
                return { shouldRetry: false, error: error.message };
            }
        };

        // IndexedDB setup
        const dbName = 'ttsDB';
        const dbVersion = 1;
        let db;

        // Initialize IndexedDB
        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, dbVersion);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create object stores if they don't exist
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings');
                    }
                    if (!db.objectStoreNames.contains('history')) {
                        const historyStore = db.createObjectStore('history', { keyPath: 'timestamp' });
                        // Tạo index cho timestamp để sắp xếp
                        historyStore.createIndex('timestamp', 'timestamp');
                    }
                };
            });
        };

        // Save data to IndexedDB
        const saveToIndexedDB = (storeName, key, value) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(value, key);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        };

        // Get data from IndexedDB
        const getFromIndexedDB = (storeName, key) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        };

        // Get all data from store
        const getAllFromStore = (storeName) => {
            return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();

                    request.onerror = () => {
                        console.error('Error getting all from store:', request.error);
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        // Sort entries by timestamp in descending order (newest first)
                        const results = request.result || [];
                        if (storeName === 'history') {
                            results.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        }
                        resolve(results);
                    };
                    
                    transaction.onerror = (event) => {
                        console.error('Transaction error:', event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.error('Error in getAllFromStore:', error);
                    reject(error);
                }
            });
        };

        // Delete data from IndexedDB
        const deleteFromIndexedDB = (storeName, key) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        };

        // Clear entire object store
        const clearObjectStore = (storeName) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        };

        
        // Extract keywords using Gemini
        async function extractKeywords(text) {
            async function attemptExtract(apiKey) {
                const response = await fetch(`${endpointBaseModelText}/gemini-2.0-flash:generateContent`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-goog-api-key': apiKey
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `Trích xuất 3-5 từ khóa chính từ đoạn văn sau (trả về dưới dạng danh sách các từ khóa, mỗi từ khóa một dòng):\n\n${text}`
                            }]
                        }]
                    })
                });

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(errText);
                }

                const data = await response.json();
                return data?.candidates?.[0]?.content?.parts?.[0]?.text
                    .split('\n')
                    .map(k => k.trim())
                    .filter(k => k);
            }

            try {
                let currentKey = await keyManager.getCurrentKey();
                while (true) {
                    try {
                        return await attemptExtract(currentKey);
                    } catch (error) {
                        const { shouldRetry, key, error: errMsg } = await keyManager.handleApiError(error);
                        if (shouldRetry && key) {
                            currentKey = key;
                            continue;
                        }
                        throw new Error(errMsg);
                    }
                }
            } catch (error) {
                console.error('Error extracting keywords:', error);
                return [];
            }
        }



        // Update related content UI
        async function updateRelatedContent(keywords) {
            const keywordsContainer = document.getElementById('keywords');

            // Display keywords
            keywordsContainer.innerHTML = keywords.map(k => `
                <span class="keyword-tag">${k}</span>
            `).join('');

            // Show the related content section
            document.getElementById('related-content').style.display = 'block';
        }
        
        // Process URL and generate summary
        async function processUrl() {
            const urlInput = document.getElementById('url-input');
            const text = document.getElementById('text');
            const spinner = document.getElementById('loading-spinner');
            const processButton = document.getElementById('process-url');
            const url = urlInput.value.trim(); 

            if (!url) {
                alert('Vui lòng nhập link cần tóm tắt');
                return;
            }
            text.value = ''; // Clear previous text
            // Show loading state
            spinner.classList.remove('d-none');
            processButton.disabled = true;

            try { 
                // Call Gemini API for summarization
                const geminiUrl = `${endpointBaseModelText}/gemini-2.0-flash:generateContent`;
                const payload = {
                    contents: [{
                        parts: [{
                            text: `Viết lại nội dung của bài viết trong link sau, gom lại thành 1 đoạn để tôi copy vào công cụ text to speech để làm video:\n\n${url}`
                        }]
                    }],
                    generationConfig: {
                        temperature: 0.7,
                        topK: 32,
                        topP: 1,
                        maxOutputTokens: 1024,
                    }
                };

                const geminiResponse = await fetch(geminiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-goog-api-key': "AIzaSyCMVNsdQxn-Py7ae_8GTGp6t3OXNRLSNy0"
                    },
                    body: JSON.stringify(payload)
                });

                if (!geminiResponse.ok) {
                    throw new Error('Lỗi khi gọi Gemini API');
                }

                const result = await geminiResponse.json();
                const summary = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (summary) {
                    text.value = summary.trim();
                    // Save to localStorage
                    localStorage.setItem('tts-text', text.value);  
                } else {
                    throw new Error('Không nhận được kết quả tóm tắt');
                }

            } catch (error) {
                console.error('Error:', error);
                if (error.message === 'Failed to fetch') {
                    alert('Vui lòng bật CORS Extension trên Chrome để đọc được nội dung từ website khác.\n\nBạn có thể cài đặt extension "Allow CORS: Access-Control-Allow-Origin" từ Chrome Web Store.');
                } else {
                    alert('Có lỗi xảy ra: ' + error.message);
                }
            } finally {
                // Hide loading state
                spinner.classList.add('d-none');
                processButton.disabled = false;
            }
        }
        
        // Load saved form values from IndexedDB
        async function loadSavedValues() {
            try {
                const model = await getFromIndexedDB('settings', 'model');
                const voice = await getFromIndexedDB('settings', 'voice');
                const stylePersona = await getFromIndexedDB('settings', 'stylePersona');
                const text = await getFromIndexedDB('settings', 'text');
                const url = await getFromIndexedDB('settings', 'url');

                if (model) document.getElementById('model').value = model;
                if (voice) document.getElementById('voice').value = voice;
                if (stylePersona) document.getElementById('style-persona').value = stylePersona;
                if (text) document.getElementById('text').value = text;
                if (url) document.getElementById('url-input').value = url;

                // Load and display history
                await displayHistory();
            } catch (error) {
                console.error('Error loading saved values:', error);
            }
        }

        // Save form values to IndexedDB
        async function saveFormValues() {
            try {
                const model = document.getElementById('model').value;
                const voice = document.getElementById('voice').value;
                const stylePersona = document.getElementById('style-persona').value;
                const text = document.getElementById('text').value;

                await saveToIndexedDB('settings', 'model', model);
                await saveToIndexedDB('settings', 'voice', voice);
                await saveToIndexedDB('settings', 'stylePersona', stylePersona);
                await saveToIndexedDB('settings', 'text', text);
            } catch (error) {
                console.error('Error saving form values:', error);
            }
        }

        // Save to history
        async function saveToHistory(text, audioBlob) {
            try {
                // Convert audioBlob to base64
                const base64Audio = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsDataURL(audioBlob);
                });

                // Create history entry
                const entry = {
                    rawText: document.getElementById('text').value,
                    stylePersona: document.getElementById('style-persona').value,
                    text,
                    model: document.getElementById('model').value,
                    voice: document.getElementById('voice').value,
                    timestamp: new Date().toISOString(),
                    audioData: base64Audio
                };

                // Get existing history
                const history = await getAllFromStore('history') || [];
                
                // Add new entry and limit to 5 items
                history.unshift(entry);
                if (history.length > 5) {
                    // Remove old entries
                    const itemsToRemove = history.slice(5);
                    for (const oldEntry of itemsToRemove) {
                        await deleteFromIndexedDB('history', oldEntry.timestamp);
                    }
                    history.length = 5;
                }

                // Save new entry
                const transaction = db.transaction('history', 'readwrite');
                const store = transaction.objectStore('history');
                
                try {
                    await new Promise((resolve, reject) => {
                        const request = store.add(entry);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (storageError) {
                    console.warn('Error saving with audio, trying without:', storageError);
                    delete entry.audioData;
                    await saveToIndexedDB('history', entry.timestamp, entry);
                }

                await displayHistory();
            } catch (error) {
                console.error('Error in saveToHistory:', error);
            }
        }

        // Display history
        async function displayHistory() {
            const historyContainer = document.getElementById('history-list');
            const history = await getAllFromStore('history') || [];
            
            historyContainer.innerHTML = history.map((entry, index) => {
                // Đảm bảo có rawText, nếu không thì dùng text
                const displayText = entry.rawText || entry.text || '';
                const stylePersona = entry.stylePersona || '';
                
                return `
                <div class="history-item p-3 border-bottom">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <small class="text-muted">${new Date(entry.timestamp).toLocaleString()}</small>
                        <div>
                            <button class="btn btn-sm btn-link" onclick="loadHistoryEntry(${index})">
                                <i class="bi bi-arrow-counterclockwise"></i> Sử dụng lại
                            </button>
                            <button class="btn btn-sm btn-link" onclick="playHistoryAudio(${index})">
                                <i class="bi bi-play-circle"></i> Nghe
                            </button>
                        </div>
                    </div>
                    <div class="small mb-1">${displayText.substring(0, 100)}${displayText.length > 100 ? '...' : ''}</div> 
                    <small class="text-muted">Style: ${stylePersona}, Voice: ${entry.voice}, Model: ${entry.model}</small>
                </div>
                `;
            }).join('');
        }

        // Play audio from history
        async function playHistoryAudio(index) {
            try {
                const history = await getAllFromStore('history') || [];
                const entry = history[index];
                if (entry && entry.audioData) {
                    try {
                        // Convert base64 back to blob
                        const byteCharacters = atob(entry.audioData);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: 'audio/wav' });
                        
                        const urlObj = URL.createObjectURL(blob);
                        const audio = document.getElementById('player');
                        audio.src = urlObj;
                        audio.play().catch(() => { /* user gesture may be required */ });

                        // Update download link
                        const a = document.createElement('a');
                        a.href = urlObj;
                        a.className = 'd-block mt-2 btn btn-secondary';
                        a.download = 'gemini-tts.wav';
                        a.textContent = 'Tải về: gemini-tts.wav';
                        const dl = document.getElementById('download');
                        dl.innerHTML = '';
                        dl.appendChild(a);
                    } catch (error) {
                        console.error('Error playing audio from history:', error);
                    }
                } else {
                    console.log('No audio data available for this history entry');
                }
            } catch (error) {
                console.error('Error accessing history:', error);
            }
        }

        // Load history entry
        async function loadHistoryEntry(index) {
            try {
                const history = await getAllFromStore('history') || [];
                const entry = history[index];
                if (entry) {
                    document.getElementById('model').value = entry.model;
                    document.getElementById('voice').value = entry.voice;
                    document.getElementById('style-persona').value = entry.stylePersona || '';
                    document.getElementById('text').value = entry.rawText; // Load original text without style
                    // Also play the saved audio
                    await playHistoryAudio(index);
                }
            } catch (error) {
                console.error('Error loading history entry:', error);
            }
        }

        // Clear history
        async function clearHistory() {
            if (confirm('Bạn có chắc chắn muốn xóa toàn bộ lịch sử?')) {
                try {
                    await clearObjectStore('history');
                    await displayHistory();
                } catch (error) {
                    console.error('Error clearing history:', error);
                }
            }
        }

        // Chuyển Base64 PCM (s16le 24kHz mono) -> Blob WAV
        function pcmBase64ToWavBlob(b64, sampleRate = 24000, numChannels = 1, bytesPerSample = 2) {
            const raw = atob(b64);
            const pcmData = new Uint8Array(raw.length);
            for (let i = 0; i < raw.length; i++) pcmData[i] = raw.charCodeAt(i);

            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.byteLength;
            const headerSize = 44;
            const buffer = new ArrayBuffer(headerSize + dataSize);
            const view = new DataView(buffer);

            // RIFF header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            // fmt  subchunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);            // Subchunk1Size
            view.setUint16(20, 1, true);             // AudioFormat = PCM
            view.setUint16(22, numChannels, true);   // NumChannels
            view.setUint32(24, sampleRate, true);    // SampleRate
            view.setUint32(28, byteRate, true);      // ByteRate
            view.setUint16(32, blockAlign, true);    // BlockAlign
            view.setUint16(34, bytesPerSample * 8, true); // BitsPerSample

            // data subchunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // PCM payload
            new Uint8Array(buffer, headerSize).set(pcmData);

            return new Blob([buffer], { type: 'audio/wav' });

            function writeString(dv, offset, str) {
                for (let i = 0; i < str.length; i++) dv.setUint8(offset + i, str.charCodeAt(i));
            }
        }

        async function generateTTS() {
            var text = document.getElementById('text').value;
            const voice = document.getElementById('voice').value;
            const model = document.getElementById('model').value;
            const stylePersona = document.getElementById('style-persona').value.trim();
            const generateBtn = document.getElementById('go');
            const generateBtnText = document.getElementById('generate-btn-text');
            const generateSpinner = document.getElementById('generate-spinner');

            // Hàm thực hiện gọi API TTS
            async function attemptTTS(apiKey) {
                const res = await fetch(`${endpointBase}/models/${encodeURIComponent(model)}:generateContent`, {
                    method: "POST",
                    headers: {
                        "x-goog-api-key": apiKey,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: voice }
                                }
                            }
                        },
                        model
                    })
                });

                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(errText);
                }

                return await res.json();
            }
            
            // Save form values
            saveFormValues();

            const log = (msg) => document.getElementById('log').textContent = String(msg ?? '');

            if (!text) { alert("Nhập nội dung cần đọc."); return; }
            
            // Show loading state
            generateBtn.disabled = true;
            generateBtnText.textContent = 'Đang tạo...';
            generateSpinner.classList.remove('d-none');
            
            if (stylePersona) {
                // Thêm style/persona vào đầu đoạn text, nếu có
                text = `Đọc với phong cách / ${stylePersona}:\n\n${text}`;
            }
            console.log(text);

            try {
                let currentKey = await keyManager.getCurrentKey();
                let data;

                while (true) {
                    try {
                        log(`Đang gọi Gemini TTS với key ${currentKey.substring(0, 10)}...`);
                        data = await attemptTTS(currentKey);
                        break;
                    } catch (error) {
                        const { shouldRetry, key, error: errMsg } = await keyManager.handleApiError(error);
                        if (shouldRetry && key) {
                            currentKey = key;
                            log(`Thử lại với key mới ${key.substring(0, 10)}...`);
                            continue;
                        }
                        throw new Error(errMsg);
                    }
                }

                // Lấy Base64 PCM từ inlineData
                const b64 = data?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                if (!b64) throw new Error("Không tìm thấy audio trong phản hồi API.");
                
              
                // Đổi sang WAV rồi phát
                const wavBlob = pcmBase64ToWavBlob(b64, 24000, 1, 2);
                const urlObj = URL.createObjectURL(wavBlob);

                const audio = document.getElementById('player');
                audio.src = urlObj;
                audio.play().catch(() => { /* user gesture may be required */ });

                // Link tải
                const a = document.createElement('a');
                a.href = urlObj;
                a.download = 'gemini-tts.wav';
                a.className = 'd-block mt-2 btn btn-secondary';
                a.textContent = 'Tải về: gemini-tts.wav';
                const dl = document.getElementById('download');
                dl.innerHTML = '';
                dl.appendChild(a);

                log("Xong. Nếu không nghe được, thử bấm Play thủ công hoặc tải file về.");
                
                // Save to history after successful generation
                saveToHistory(text, wavBlob);
            } catch (e) {
                log(e.message || e.toString());
                alert("Gọi API thất bại. Xem log ở dưới để biết chi tiết.");
            } finally {
                // Reset button state
                generateBtn.disabled = false;
                generateBtnText.textContent = 'Tạo giọng nói';
                generateSpinner.classList.add('d-none');
            }
        }

        // Save text content whenever it changes
        document.getElementById('text').addEventListener('input', async function() {
            await saveToIndexedDB('settings', 'text', this.value);
        });

        // Add event listeners
        document.getElementById('go').addEventListener('click', generateTTS);
        document.getElementById('process-url').addEventListener('click', processUrl);
        document.getElementById('url-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                processUrl();
            }
        });


        // Save URL input whenever it changes
        document.getElementById('url-input').addEventListener('input', async function() {
            await saveToIndexedDB('settings', 'url', this.value);
        });
        
        // Initialize DB and load saved values when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await initDB();
                await loadSavedValues();
            } catch (error) {
                console.error('Error initializing app:', error);
            }
        });
    </script>
</body>

</html>